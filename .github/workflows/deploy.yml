name: Deploy to Kubernetes

on:
  # Manual trigger with service selection
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy (or "all" for all services)'
        required: true
        type: choice
        options:
          - all
          - user-management
          - notification-service
          - routing-service
          - safety-scoring
          - sos
          - feedback

  # Webhook trigger from CI repositories
  repository_dispatch:
    types: [deploy-service]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout manifests
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          # Determine service from manual trigger or webhook
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SERVICE="${{ github.event.inputs.service }}"
          else
            SERVICE="${{ github.event.client_payload.service }}"
          fi
          
          echo "service=${SERVICE}" >> $GITHUB_OUTPUT
          
          echo "ðŸš€ Deploying service: ${SERVICE}"

      - name: Get latest image tags from Docker Hub
        id: get_tags
        run: |
          SERVICE="${{ steps.vars.outputs.service }}"
          
          # Map service names to their image names
          declare -A IMAGE_MAP=(
            ["user-management"]="saferoute/user-management"
            ["notification-service"]="saferoute/notification"
            ["routing-service"]="saferoute/routing-service"
            ["safety-scoring"]="saferoute/safety-scoring"
            ["sos"]="saferoute/sos"
            ["feedback"]="saferoute/feedback"
          )
          
          get_latest_tag() {
            local image_name=$1
            
            echo "ðŸ” Fetching latest tag for ${image_name}..." >&2
            
            # Get the latest tag from Docker Hub (excluding 'latest' and 'buildcache')
            # This fetches the most recently pushed tag
            local latest_tag=$(curl -s "https://hub.docker.com/v2/repositories/${image_name}/tags/?page_size=100" | \
              jq -r '.results[] | select(.name != "latest" and .name != "buildcache") | .name' | \
              head -n 1)
            
            if [ -z "$latest_tag" ]; then
              echo "âš ï¸  No tags found, falling back to 'latest'" >&2
              latest_tag="latest"
            fi
            
            echo "âœ… Latest tag for ${image_name}: ${latest_tag}" >&2
            echo "$latest_tag"
          }
          
          # Store tags for each service
          declare -A SERVICE_TAGS
          
          if [ "$SERVICE" == "all" ]; then
            echo "ðŸ“¦ Fetching latest tags for all services..." >&2
            for svc in "${!IMAGE_MAP[@]}"; do
              image_name="${IMAGE_MAP[$svc]}"
              tag=$(get_latest_tag "$image_name")
              SERVICE_TAGS["$svc"]="$tag"
              echo "${svc}_tag=${tag}" >> $GITHUB_OUTPUT
            done
          else
            echo "ðŸ“¦ Fetching latest tag for ${SERVICE}..." >&2
            image_name="${IMAGE_MAP[$SERVICE]}"
            tag=$(get_latest_tag "$image_name")
            SERVICE_TAGS["$SERVICE"]="$tag"
            echo "${SERVICE}_tag=${tag}" >> $GITHUB_OUTPUT
          fi

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Install yq for YAML processing
        run: |
          # Install yq for filtering StorageClass resources from YAML
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 || \
            curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
          yq --version || echo "âš ï¸ yq installation failed, will use fallback method"

      - name: Configure Kubernetes context
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
          # Verify connection
          kubectl cluster-info
          kubectl get nodes

      - name: Update image tags in manifests
        run: |
          SERVICE="${{ steps.vars.outputs.service }}"
          
          # Map service names to their image names
          declare -A IMAGE_MAP=(
            ["user-management"]="saferoute/user-management"
            ["notification-service"]="saferoute/notification"
            ["routing-service"]="saferoute/routing-service"
            ["safety-scoring"]="saferoute/safety-scoring"
            ["sos"]="saferoute/sos"
            ["feedback"]="saferoute/feedback"
          )
          
          update_deployment() {
            local svc=$1
            local deployment_file="k8s/saferoute/${svc}/deployment.yml"
            
            # Get the tag for this service
            local tag
            if [ "$svc" == "user-management" ]; then
              tag="${{ steps.get_tags.outputs.user-management_tag }}"
            elif [ "$svc" == "notification-service" ]; then
              tag="${{ steps.get_tags.outputs.notification-service_tag }}"
            elif [ "$svc" == "routing-service" ]; then
              tag="${{ steps.get_tags.outputs.routing-service_tag }}"
            elif [ "$svc" == "safety-scoring" ]; then
              tag="${{ steps.get_tags.outputs.safety-scoring_tag }}"
            elif [ "$svc" == "sos" ]; then
              tag="${{ steps.get_tags.outputs.sos_tag }}"
            elif [ "$svc" == "feedback" ]; then
              tag="${{ steps.get_tags.outputs.feedback_tag }}"
            fi
            
            if [ -f "$deployment_file" ]; then
              local image_name="${IMAGE_MAP[$svc]}"
              echo "ðŸ“ Updating ${deployment_file} with ${image_name}:${tag}"
              
              # Update image tag in deployment file
              sed -i "s|image: ${image_name}:.*|image: ${image_name}:${tag}|g" "$deployment_file"
              
              echo "âœ… Updated ${svc} to ${tag}"
            else
              echo "âš ï¸  Warning: ${deployment_file} not found"
            fi
          }
          
          if [ "$SERVICE" == "all" ]; then
            echo "ðŸ”„ Updating all services..."
            for svc in "${!IMAGE_MAP[@]}"; do
              update_deployment "$svc"
            done
          else
            echo "ðŸ”„ Updating ${SERVICE}..."
            update_deployment "$SERVICE"
          fi

      - name: Verify Docker images exist
        run: |
          SERVICE="${{ steps.vars.outputs.service }}"
          
          # Map service names to their image names
          declare -A IMAGE_MAP=(
            ["user-management"]="saferoute/user-management"
            ["notification-service"]="saferoute/notification"
            ["routing-service"]="saferoute/routing-service"
            ["safety-scoring"]="saferoute/safety-scoring"
            ["sos"]="saferoute/sos"
            ["feedback"]="saferoute/feedback"
          )
          
          verify_image() {
            local svc=$1
            local image_name="${IMAGE_MAP[$svc]}"
            
            # Get the tag for this service
            local tag
            if [ "$svc" == "user-management" ]; then
              tag="${{ steps.get_tags.outputs.user-management_tag }}"
            elif [ "$svc" == "notification-service" ]; then
              tag="${{ steps.get_tags.outputs.notification-service_tag }}"
            elif [ "$svc" == "routing-service" ]; then
              tag="${{ steps.get_tags.outputs.routing-service_tag }}"
            elif [ "$svc" == "safety-scoring" ]; then
              tag="${{ steps.get_tags.outputs.safety-scoring_tag }}"
            elif [ "$svc" == "sos" ]; then
              tag="${{ steps.get_tags.outputs.sos_tag }}"
            elif [ "$svc" == "feedback" ]; then
              tag="${{ steps.get_tags.outputs.feedback_tag }}"
            fi
            
            local full_image="${image_name}:${tag}"
            
            echo "ðŸ” Verifying ${full_image} exists on Docker Hub..."
            
            # Check if image exists (this will pull the manifest, not the full image)
            if docker manifest inspect "${full_image}" > /dev/null 2>&1; then
              echo "âœ… Image ${full_image} verified"
            else
              echo "âŒ Error: Image ${full_image} not found on Docker Hub"
              exit 1
            fi
          }
          
          if [ "$SERVICE" == "all" ]; then
            for svc in "${!IMAGE_MAP[@]}"; do
              verify_image "$svc"
            done
          else
            verify_image "$SERVICE"
          fi

      - name: Deploy to Kubernetes
        run: |
          SERVICE="${{ steps.vars.outputs.service }}"
          
          # Helper function to apply manifests while handling immutable resources
          # StorageClasses, PVCs, and StatefulSets have immutable fields that cannot be updated
          apply_without_storageclass() {
            local manifest_path=$1
            local temp_file=$(mktemp)
            local has_storageclass=false
            
            # Check if file contains PVC resources and if they already exist
            if grep -qE "^\s*kind:\s*PersistentVolumeClaim\s*$" "$manifest_path"; then
              # Extract PVC name and namespace using yq if available, otherwise use grep
              if command -v yq >/dev/null 2>&1; then
                local pvc_name=$(yq eval '.metadata.name' "$manifest_path" 2>/dev/null | head -1)
                local pvc_namespace=$(yq eval '.metadata.namespace // "default"' "$manifest_path" 2>/dev/null | head -1)
              else
                # Fallback: use grep to extract name and namespace
                local pvc_name=$(grep -A 5 "kind:\s*PersistentVolumeClaim" "$manifest_path" | grep -E "^\s*name:\s*" | head -1 | awk '{print $2}' | tr -d '"' | tr -d "'")
                local pvc_namespace=$(grep -A 10 "kind:\s*PersistentVolumeClaim" "$manifest_path" | grep -E "^\s*namespace:\s*" | head -1 | awk '{print $2}' | tr -d '"' | tr -d "'" || echo "default")
              fi
              
              if [ -n "$pvc_name" ] && kubectl get pvc "$pvc_name" -n "$pvc_namespace" >/dev/null 2>&1; then
                echo "â„¹ï¸  PVC $pvc_name already exists in namespace $pvc_namespace, skipping (PVCs are immutable - storageClassName cannot be changed)"
                rm -f "$temp_file"
                return 0
              fi
            fi
            
            # Check if file contains StorageClass resources
            if grep -qE "^\s*kind:\s*StorageClass\s*$" "$manifest_path"; then
              has_storageclass=true
              echo "âš ï¸ Detected StorageClass in $manifest_path, filtering it out..."
            fi
            
            if [ "$has_storageclass" = true ] && command -v yq >/dev/null 2>&1; then
              # Use yq to filter out StorageClass resources
              # Split by document separator and filter
              yq eval-all 'select(.kind != "StorageClass")' "$manifest_path" > "$temp_file" 2>/dev/null || {
                # Fallback: try single document mode
                yq eval 'select(.kind != "StorageClass")' "$manifest_path" > "$temp_file" 2>/dev/null || {
                  cp "$manifest_path" "$temp_file"
                }
              }
            else
              cp "$manifest_path" "$temp_file"
            fi
            
            # Apply the manifest and handle immutable resource errors gracefully
            local output_file=$(mktemp)
            local exit_code=0
            kubectl apply -f "$temp_file" > "$output_file" 2>&1 || exit_code=$?
            
            if [ $exit_code -ne 0 ]; then
              # Check if error is StorageClass related
              if grep -qE "StorageClass.*is invalid|Forbidden.*updates to (parameters|reclaimPolicy) are forbidden" "$output_file"; then
                echo "âš ï¸ Warning: StorageClass update skipped (managed by AKS - immutable fields)"
                # Show non-error output
                grep -vE "StorageClass.*is invalid|Forbidden.*updates" "$output_file" || true
              # Check if error is PVC immutability related
              elif grep -qE "PersistentVolumeClaim.*is invalid|spec.*is immutable after creation" "$output_file"; then
                echo "âš ï¸ Warning: PersistentVolumeClaim update skipped (immutable after creation - storageClassName cannot be changed)"
                echo "â„¹ï¸  The PVC already exists with different spec. Only storage size can be updated for existing PVCs."
                # Show non-error output
                grep -vE "PersistentVolumeClaim.*is invalid|spec.*is immutable" "$output_file" || true
              # Check if error is StatefulSet immutability related
              elif grep -qE "StatefulSet.*is invalid|Forbidden.*updates to statefulset spec" "$output_file"; then
                echo "âš ï¸ Warning: StatefulSet update skipped (immutable fields detected)"
                echo "â„¹ï¸  StatefulSet spec fields like volumeClaimTemplates are immutable after creation."
                echo "â„¹ï¸  Only replicas, template, updateStrategy, and minReadySeconds can be updated."
                echo "â„¹ï¸  To change immutable fields, delete and recreate the StatefulSet (data will be preserved if PVCs exist)."
                # Show non-error output
                grep -vE "StatefulSet.*is invalid|Forbidden.*updates to statefulset" "$output_file" || true
              else
                # Non-immutable resource error - show and fail
                cat "$output_file"
                rm -f "$temp_file" "$output_file"
                exit $exit_code
              fi
            else
              # Success - show output
              cat "$output_file"
            fi
            
            rm -f "$temp_file" "$output_file"
          }
          
          # Helper function to apply directory while excluding StorageClass resources
          apply_dir_without_storageclass() {
            local dir_path=$1
            for manifest in "$dir_path"/*.yml "$dir_path"/*.yaml; do
              if [ -f "$manifest" ]; then
                # For PVCs, check if they already exist and skip if they do
                if grep -qE "^\s*kind:\s*PersistentVolumeClaim\s*$" "$manifest"; then
                  local pvc_name=$(grep -E "^\s*name:\s*" "$manifest" | head -1 | awk '{print $2}' | tr -d '"' | tr -d "'")
                  local pvc_namespace=$(grep -E "^\s*namespace:\s*" "$manifest" | head -1 | awk '{print $2}' | tr -d '"' | tr -d "'" || echo "default")
                  
                  if kubectl get pvc "$pvc_name" -n "$pvc_namespace" >/dev/null 2>&1; then
                    echo "â„¹ï¸  PVC $pvc_name already exists in namespace $pvc_namespace, skipping (PVCs are immutable)"
                    continue
                  fi
                fi
                apply_without_storageclass "$manifest"
              fi
            done
          }
          
          deploy_service() {
            local svc=$1
            local service_dir="k8s/saferoute/${svc}"
            
            echo "ðŸš€ Deploying ${svc}..."
            
            # Apply configmap if exists
            if [ -f "${service_dir}/configmap.yml" ]; then
              apply_without_storageclass "${service_dir}/configmap.yml"
            fi
            
            # Apply service
            if [ -f "${service_dir}/service.yml" ]; then
              apply_without_storageclass "${service_dir}/service.yml"
            fi
            
            # Apply deployment
            if [ -f "${service_dir}/deployment.yml" ]; then
              apply_without_storageclass "${service_dir}/deployment.yml"
            fi
            
            # Wait for rollout to complete
            if [ -f "${service_dir}/deployment.yml" ]; then
              echo "â³ Waiting for ${svc} rollout to complete..."
              kubectl rollout status deployment/${svc} -n saferoute --timeout=5m
              echo "âœ… ${svc} deployed successfully"
            fi
          }
          
          if [ "$SERVICE" == "all" ]; then
            echo "ðŸš€ Deploying all services..."
            
            # Deploy namespaces (if manifests exist)
            if compgen -G "k8s/namespaces/*.yml" > /dev/null; then
              apply_dir_without_storageclass "k8s/namespaces"
            else
              echo "â„¹ï¸ No namespace manifests found"
            fi

            # Deploy base manifests but skip any storage classes (AKS manages them)
            if compgen -G "k8s/base/*.yml" > /dev/null; then
              for manifest in k8s/base/*.yml; do
                if echo "$(basename "$manifest")" | grep -qi "storageclass"; then
                  echo "âš ï¸ Skipping storage class manifest: $manifest"
                  continue
                fi
                apply_without_storageclass "$manifest"
              done
            else
              echo "â„¹ï¸ No base manifests found"
            fi
            
            # Deploy data layer
            if compgen -G "k8s/data/postgresql/*.yml" > /dev/null; then
              apply_dir_without_storageclass "k8s/data/postgresql"
            fi
            if compgen -G "k8s/data/redis/*.yml" > /dev/null; then
              apply_dir_without_storageclass "k8s/data/redis"
            fi
            
            # Deploy RabbitMQ
            if [ -f k8s/secrets/rabbitmq-secret.yml ]; then
              apply_without_storageclass "k8s/secrets/rabbitmq-secret.yml"
            fi
            if [ -d k8s/saferoute/rabbitmq ]; then
              apply_dir_without_storageclass "k8s/saferoute/rabbitmq"
            fi
            
            # Deploy all microservices
            for svc in user-management notification-service routing-service safety-scoring sos feedback; do
              deploy_service "$svc"
            done
            
            # Deploy ingress
            if [ -f k8s/saferoute/ingress.yml ]; then
              apply_without_storageclass "k8s/saferoute/ingress.yml"
            fi
            
          else
            deploy_service "$SERVICE"
          fi

      - name: Verify deployment
        run: |
          SERVICE="${{ steps.vars.outputs.service }}"
          
          echo "ðŸ” Verifying deployment status..."
          
          if [ "$SERVICE" == "all" ]; then
            kubectl get pods -n saferoute
            kubectl get services -n saferoute
          else
            kubectl get pods -n saferoute -l app=${SERVICE}
            kubectl describe deployment ${SERVICE} -n saferoute
          fi

      - name: Commit updated manifests
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'repository_dispatch'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          SERVICE="${{ steps.vars.outputs.service }}"
          
          git add k8s/saferoute/*/deployment.yml
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Deploy ${SERVICE} with latest Docker Hub images"
            git push
          fi

      - name: Deployment summary
        if: always()
        run: |
          SERVICE="${{ steps.vars.outputs.service }}"
          
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: ${SERVICE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$SERVICE" == "all" ]; then
            echo "### ðŸ“¦ Deployed Images" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Service | Image Tag |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|-----------|" >> $GITHUB_STEP_SUMMARY
            echo "| user-management | \`${{ steps.get_tags.outputs.user-management_tag }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| notification-service | \`${{ steps.get_tags.outputs.notification-service_tag }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| routing-service | \`${{ steps.get_tags.outputs.routing-service_tag }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| safety-scoring | \`${{ steps.get_tags.outputs.safety-scoring_tag }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| sos | \`${{ steps.get_tags.outputs.sos_tag }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| feedback | \`${{ steps.get_tags.outputs.feedback_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          else
            if [ "$SERVICE" == "user-management" ]; then
              TAG="${{ steps.get_tags.outputs.user-management_tag }}"
            elif [ "$SERVICE" == "notification-service" ]; then
              TAG="${{ steps.get_tags.outputs.notification-service_tag }}"
            elif [ "$SERVICE" == "routing-service" ]; then
              TAG="${{ steps.get_tags.outputs.routing-service_tag }}"
            elif [ "$SERVICE" == "safety-scoring" ]; then
              TAG="${{ steps.get_tags.outputs.safety-scoring_tag }}"
            elif [ "$SERVICE" == "sos" ]; then
              TAG="${{ steps.get_tags.outputs.sos_tag }}"
            elif [ "$SERVICE" == "feedback" ]; then
              TAG="${{ steps.get_tags.outputs.feedback_tag }}"
            fi
            echo "- **Image Tag**: \`${TAG}\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Deployment failed. Check the logs for details." >> $GITHUB_STEP_SUMMARY
          fi

